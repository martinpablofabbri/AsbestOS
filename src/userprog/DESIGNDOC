                     +--------------------------+
       	       	     |          CS 124          |
                     | PROJECT 4: USER PROGRAMS |
                     |     DESIGN DOCUMENT      |
                     +--------------------------+

---- GROUP ----

>> Fill in the names and email addresses of your group members.

AsbestOS

Keegan    Ryan      karyan@caltech.edu
Jalen     Green     jpgreen@caltech.edu
Martin    Fabbri    mfabbri@caltech.edu

>> Specify how many late tokens you are using on this assignment:
0

>> What is the Git repository and commit hash for your submission?

   Repository URL: https://github.com/keeganryan/AsbestOS
   commit ...

---- PRELIMINARIES ----

>> If you have any preliminary comments on your submission, notes for the
>> TAs, or extra credit, please give them here.

>> Please cite any offline or online sources you consulted while
>> preparing your submission, other than the Pintos documentation, course
>> text, lecture notes, and course instructors.

                           ARGUMENT PASSING
                           ================

---- DATA STRUCTURES ----

>> A1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

struct thread {
    ...
    struct child_info* child_head;      /*!< Head of the doubly linked
                                         list of children. */
    struct child_info* self_info;       /*!< Pointer to the child_info
                                          struct held by this
                                          thread's parent. */
    int retval;                         /*!< The return value of a
					  thread. Initialized to -1. */
    ...
    struct list open_files;             /*!< List of files opened by
                                           the process. */
    int lowest_available_fd;            /*!< Keeps track of which file
					  descriptor to give out next. */
    struct file *executing_file;        /*!< Reference to the file
                                           descriptor of the current
                                           executable. */
    ...
};

// In thread.h
/*! Information that a parent thread maintains about each of its
  children. */
struct child_info {
    struct child_info* prev;            /*!< Pointer to the previous
					  child_info struct in the
					  parent's list of children. */
    struct child_info* next;            /*!< Pointer to the next
					  child_info struct in the
					  parent's list of children. */

    tid_t child_tid;                    /*!< The thread id of the
					  child process which will
					  fill in the retval field. */

    int retval;                         /*!< Return code of the child
					  process. Defaults to -1. */

    bool child_is_dead;                 /*!< Flag used to indicate
					  when a child has died, and
					  thus when retval is
					  accurate. */
    struct lock child_lock;             /*!< Lock that is accessible
					  by both the parent and the
					  parent's child with the
					  given tid. */
    struct condition has_exited;        /*!< Condition variable used
                                           by the parent and the child
                                           to signal the death of
                                           child. */
};

// In syscall.c
static struct lock filesys_lock; /*!< Lock to prevent concurrent
				   access to filesys.c functions. */

/* Struct for list element with a file and file descriptor */
struct file_item {
    struct list_elem elem;               /*!< List element of
					   file_item. */
    struct file *file;                   /*!< Reference to file
					   returned by filesys code. */
    int fd;                              /*!< File descriptor
					   associated with the file. */
};

// In process.c
/*! Lock used to prevent problems of multiple threads dying at the
  same time. */
static struct lock death_lock;

/*! Define the format by which creation arguments are passed to child
  processes. */
struct process_start_args {
    struct semaphore* start_sema;        /*!< Semaphore used by the
					   child to signal either
					   successful or failed
					   creation. */
    bool* started_successfully;          /*!< Reference to a boolean
					   value the child process
					   sets in order to signal how
					   creation went. */
    char* argv_start;                    /*!< Pointer to the start of
					   the argv array of
					   arguments. The array is
					   variable length. */
};


---- ALGORITHMS ----

>> A2: Briefly describe how you implemented argument parsing.  How do
>> you arrange for the elements of argv[] to be in the right order?
>> How do you avoid overflowing the stack page?

TODO

---- RATIONALE ----

>> A3: Why does Pintos implement strtok_r() but not strtok()?

TODO

>> A4: In Pintos, the kernel separates commands into a executable name
>> and arguments.  In Unix-like systems, the shell does this
>> separation.  Identify at least two advantages of the Unix approach.

TODO

                             SYSTEM CALLS
                             ============

---- DATA STRUCTURES ----

>> B1: Copy here the declaration of each new or changed `struct' or
>> `struct' member, global or static variable, `typedef', or
>> enumeration.  Identify the purpose of each in 25 words or less.

TODO

>> B2: Describe how file descriptors are associated with open files.
>> Are file descriptors unique within the entire OS or just within a
>> single process?

TODO

---- ALGORITHMS ----

>> B3: Describe your code for reading and writing user data from the
>> kernel.

TODO

>> B4: Suppose a system call causes a full page (4,096 bytes) of data
>> to be copied from user space into the kernel.  What is the least
>> and the greatest possible number of inspections of the page table
>> (e.g. calls to pagedir_get_page()) that might result?  What about
>> for a system call that only copies 2 bytes of data?  Is there room
>> for improvement in these numbers, and how much?

TODO

>> B5: Briefly describe your implementation of the "wait" system call
>> and how it interacts with process termination.

TODO

>> B6: Any access to user program memory at a user-specified address
>> can fail due to a bad pointer value.  Such accesses must cause the
>> process to be terminated.  System calls are fraught with such
>> accesses, e.g. a "write" system call requires reading the system
>> call number from the user stack, then each of the call's three
>> arguments, then an arbitrary amount of user memory, and any of
>> these can fail at any point.  This poses a design and
>> error-handling problem: how do you best avoid obscuring the primary
>> function of code in a morass of error-handling?  Furthermore, when
>> an error is detected, how do you ensure that all temporarily
>> allocated resources (locks, buffers, etc.) are freed?  In a few
>> paragraphs, describe the strategy or strategies you adopted for
>> managing these issues.  Give an example.

TODO

---- SYNCHRONIZATION ----

>> B7: The "exec" system call returns -1 if loading the new executable
>> fails, so it cannot return before the new executable has completed
>> loading.  How does your code ensure this?  How is the load
>> success/failure status passed back to the thread that calls "exec"?

TODO

>> B8: Consider parent process P with child process C.  How do you
>> ensure proper synchronization and avoid race conditions when P
>> calls wait(C) before C exits?  After C exits?  How do you ensure
>> that all resources are freed in each case?  How about when P
>> terminates without waiting, before C exits?  After C exits?  Are
>> there any special cases?

TODO

---- RATIONALE ----

>> B9: Why did you choose to implement access to user memory from the
>> kernel in the way that you did?

TODO

>> B10: What advantages or disadvantages can you see to your design
>> for file descriptors?

TODO

>> B11: The default tid_t to pid_t mapping is the identity mapping.
>> If you changed it, what advantages are there to your approach?

TODO

                           SURVEY QUESTIONS
                           ================

Answering these questions is optional, but it will help us improve the
course in future quarters.  Feel free to tell us anything you
want--these questions are just to spur your thoughts.  You may also
choose to respond anonymously in the feedback survey on the course
website.

>> In your opinion, was this assignment, or any one of the three problems
>> in it, too easy or too hard?  Did it take too long or too little time?

>> Did you find that working on a particular part of the assignment gave
>> you greater insight into some aspect of OS design?

>> Is there some particular fact or hint we should give students in
>> future quarters to help them solve the problems?  Conversely, did you
>> find any of our guidance to be misleading?

>> Do you have any suggestions for the TAs to more effectively assist
>> students, either for future quarters or the remaining projects?

>> Any other comments?

